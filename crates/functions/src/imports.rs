// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command

#![allow(unused)]

use core::fmt;
use core::mem::MaybeUninit;
pub type Size = usize;
pub type Charptr = *mut u8;
pub type Byteptr = *mut u8;
pub type StatusCode = u16;
pub type ResponseHandle = u32;
pub type CookieHandle = u32;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct SameSitePolicy(u32);
/// Strict policy
pub const SAME_SITE_POLICY_STRICT: SameSitePolicy = SameSitePolicy(0);
/// Lax policy
pub const SAME_SITE_POLICY_LAX: SameSitePolicy = SameSitePolicy(1);
/// No policy
pub const SAME_SITE_POLICY_NONE: SameSitePolicy = SameSitePolicy(2);
impl SameSitePolicy {
    pub const fn raw(&self) -> u32 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "STRICT",
            1 => "LAX",
            2 => "NONE",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "Strict policy",
            1 => "Lax policy",
            2 => "No policy",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for SameSitePolicy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SameSitePolicy")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct Error(u32);
/// Success
pub const ERROR_OK: Error = Error(0);
/// The module does not export a memory.
pub const ERROR_MISSING_MEMORY: Error = Error(1);
/// Invalid argument
pub const ERROR_INVALID_ARGUMENT: Error = Error(2);
/// Invalid UTF-8
pub const ERROR_INVALID_UTF8: Error = Error(3);
/// Invalid pointer
pub const ERROR_INVALID_POINTER: Error = Error(4);
/// Invalid buffer length
pub const ERROR_INVALID_LENGTH: Error = Error(5);
/// Invalid handle
pub const ERROR_INVALID_HANDLE: Error = Error(6);
/// Integer overflow
pub const ERROR_INTEGER_OVERFLOW: Error = Error(7);
/// Handle space exhausted
pub const ERROR_HANDLES_EXHAUSTED: Error = Error(8);
impl Error {
    pub const fn raw(&self) -> u32 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "OK",
            1 => "MISSING_MEMORY",
            2 => "INVALID_ARGUMENT",
            3 => "INVALID_UTF8",
            4 => "INVALID_POINTER",
            5 => "INVALID_LENGTH",
            6 => "INVALID_HANDLE",
            7 => "INTEGER_OVERFLOW",
            8 => "HANDLES_EXHAUSTED",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "Success",
            1 => "The module does not export a memory.",
            2 => "Invalid argument",
            3 => "Invalid UTF-8",
            4 => "Invalid pointer",
            5 => "Invalid buffer length",
            6 => "Invalid handle",
            7 => "Integer overflow",
            8 => "Handle space exhausted",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Error")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

/// Gets the length of the request HTTP method.
pub unsafe fn request_method_length() -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::request_method_length(rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the request HTTP method.
pub unsafe fn request_method_get(buffer: Charptr, buffer_len: Size) -> Result<(), Error> {
    let ret = functions::request_method_get(buffer as i32, buffer_len as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of the request URI.
pub unsafe fn request_uri_length() -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::request_uri_length(rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the request URI.
pub unsafe fn request_uri_get(buffer: Charptr, buffer_len: Size) -> Result<(), Error> {
    let ret = functions::request_uri_get(buffer as i32, buffer_len as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of a request header.
pub unsafe fn request_header_length(name: &str) -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::request_header_length(
        name.as_ptr() as i32,
        name.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets a request header.
pub unsafe fn request_header_get(
    name: &str,
    buffer: Charptr,
    buffer_len: Size,
) -> Result<(), Error> {
    let ret = functions::request_header_get(
        name.as_ptr() as i32,
        name.len() as i32,
        buffer as i32,
        buffer_len as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of a request cookie.
pub unsafe fn request_cookie_length(name: &str) -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::request_cookie_length(
        name.as_ptr() as i32,
        name.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets a request cookie.
pub unsafe fn request_cookie_get(
    name: &str,
    buffer: Charptr,
    buffer_len: Size,
) -> Result<(), Error> {
    let ret = functions::request_cookie_get(
        name.as_ptr() as i32,
        name.len() as i32,
        buffer as i32,
        buffer_len as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of a request parameter.
pub unsafe fn request_param_length(name: &str) -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::request_param_length(
        name.as_ptr() as i32,
        name.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets a request parameter.
pub unsafe fn request_param_get(
    name: &str,
    buffer: Charptr,
    buffer_len: Size,
) -> Result<(), Error> {
    let ret = functions::request_param_get(
        name.as_ptr() as i32,
        name.len() as i32,
        buffer as i32,
        buffer_len as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of the request body.
pub unsafe fn request_body_length() -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::request_body_length(rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the request body.
pub unsafe fn request_body_get(buffer: Byteptr, buffer_len: Size) -> Result<(), Error> {
    let ret = functions::request_body_get(buffer as i32, buffer_len as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Creates a new HTTP response.
pub unsafe fn response_new(status: StatusCode) -> Result<ResponseHandle, Error> {
    let mut rp0 = MaybeUninit::<ResponseHandle>::uninit();
    let ret = functions::response_new(status as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(
            rp0.as_mut_ptr() as i32 as *const ResponseHandle
        )),
        _ => Err(Error(ret as u32)),
    }
}

/// Frees the response.
pub unsafe fn response_free(response: ResponseHandle) -> Result<(), Error> {
    let ret = functions::response_free(response as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the response status code.
pub unsafe fn response_status_get(response: ResponseHandle) -> Result<StatusCode, Error> {
    let mut rp0 = MaybeUninit::<StatusCode>::uninit();
    let ret = functions::response_status_get(response as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const StatusCode)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of a response header.
pub unsafe fn response_header_length(response: ResponseHandle, name: &str) -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::response_header_length(
        response as i32,
        name.as_ptr() as i32,
        name.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets a response header.
pub unsafe fn response_header_get(
    response: ResponseHandle,
    name: &str,
    buffer: Charptr,
    buffer_len: Size,
) -> Result<(), Error> {
    let ret = functions::response_header_get(
        response as i32,
        name.as_ptr() as i32,
        name.len() as i32,
        buffer as i32,
        buffer_len as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets a response header.
pub unsafe fn response_header_set(
    response: ResponseHandle,
    name: &str,
    value: &str,
) -> Result<(), Error> {
    let ret = functions::response_header_set(
        response as i32,
        name.as_ptr() as i32,
        name.len() as i32,
        value.as_ptr() as i32,
        value.len() as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Inserts a response cookie.
pub unsafe fn response_cookie_insert(
    response: ResponseHandle,
    cookie: CookieHandle,
) -> Result<(), Error> {
    let ret = functions::response_cookie_insert(response as i32, cookie as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Removes a response cookie.
pub unsafe fn response_cookie_remove(
    response: ResponseHandle,
    cookie: CookieHandle,
) -> Result<(), Error> {
    let ret = functions::response_cookie_remove(response as i32, cookie as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the length of the response body.
pub unsafe fn response_body_length(response: ResponseHandle) -> Result<Size, Error> {
    let mut rp0 = MaybeUninit::<Size>::uninit();
    let ret = functions::response_body_length(response as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Size)),
        _ => Err(Error(ret as u32)),
    }
}

/// Gets the response body.
pub unsafe fn response_body_get(
    response: ResponseHandle,
    buffer: Byteptr,
    buffer_len: Size,
) -> Result<(), Error> {
    let ret = functions::response_body_get(response as i32, buffer as i32, buffer_len as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the response body.
pub unsafe fn response_body_set(response: ResponseHandle, body: &[u8]) -> Result<(), Error> {
    let ret =
        functions::response_body_set(response as i32, body.as_ptr() as i32, body.len() as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Creates a new response cookie.
pub unsafe fn cookie_new(name: &str, value: &str) -> Result<CookieHandle, Error> {
    let mut rp0 = MaybeUninit::<CookieHandle>::uninit();
    let ret = functions::cookie_new(
        name.as_ptr() as i32,
        name.len() as i32,
        value.as_ptr() as i32,
        value.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(
            rp0.as_mut_ptr() as i32 as *const CookieHandle
        )),
        _ => Err(Error(ret as u32)),
    }
}

/// Frees the response cookie.
pub unsafe fn cookie_free(cookie: CookieHandle) -> Result<(), Error> {
    let ret = functions::cookie_free(cookie as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the HttpOnly attribute on the cookie.
pub unsafe fn cookie_http_only_set(cookie: CookieHandle) -> Result<(), Error> {
    let ret = functions::cookie_http_only_set(cookie as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the Secure attribute on the cookie.
pub unsafe fn cookie_secure_set(cookie: CookieHandle) -> Result<(), Error> {
    let ret = functions::cookie_secure_set(cookie as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the MaxAge attribute on the cookie.
pub unsafe fn cookie_max_age_set(cookie: CookieHandle, max_age: i64) -> Result<(), Error> {
    let ret = functions::cookie_max_age_set(cookie as i32, max_age);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the SameSite attribute on the cookie.
pub unsafe fn cookie_same_site_set(
    cookie: CookieHandle,
    same_site: SameSitePolicy,
) -> Result<(), Error> {
    let ret = functions::cookie_same_site_set(cookie as i32, same_site.0 as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the Domain attribute on the cookie.
pub unsafe fn cookie_domain_set(cookie: CookieHandle, domain: &str) -> Result<(), Error> {
    let ret =
        functions::cookie_domain_set(cookie as i32, domain.as_ptr() as i32, domain.len() as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

/// Sets the Path attribute on the cookie.
pub unsafe fn cookie_path_set(cookie: CookieHandle, path: &str) -> Result<(), Error> {
    let ret = functions::cookie_path_set(cookie as i32, path.as_ptr() as i32, path.len() as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Error(ret as u32)),
    }
}

pub mod functions {
    #[link(wasm_import_module = "functions")]
    extern "C" {
        /// Gets the length of the request HTTP method.
        pub fn request_method_length(arg0: i32) -> i32;
        /// Gets the request HTTP method.
        pub fn request_method_get(arg0: i32, arg1: i32) -> i32;
        /// Gets the length of the request URI.
        pub fn request_uri_length(arg0: i32) -> i32;
        /// Gets the request URI.
        pub fn request_uri_get(arg0: i32, arg1: i32) -> i32;
        /// Gets the length of a request header.
        pub fn request_header_length(arg0: i32, arg1: i32, arg2: i32) -> i32;
        /// Gets a request header.
        pub fn request_header_get(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        /// Gets the length of a request cookie.
        pub fn request_cookie_length(arg0: i32, arg1: i32, arg2: i32) -> i32;
        /// Gets a request cookie.
        pub fn request_cookie_get(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        /// Gets the length of a request parameter.
        pub fn request_param_length(arg0: i32, arg1: i32, arg2: i32) -> i32;
        /// Gets a request parameter.
        pub fn request_param_get(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        /// Gets the length of the request body.
        pub fn request_body_length(arg0: i32) -> i32;
        /// Gets the request body.
        pub fn request_body_get(arg0: i32, arg1: i32) -> i32;
        /// Creates a new HTTP response.
        pub fn response_new(arg0: i32, arg1: i32) -> i32;
        /// Frees the response.
        pub fn response_free(arg0: i32) -> i32;
        /// Gets the response status code.
        pub fn response_status_get(arg0: i32, arg1: i32) -> i32;
        /// Gets the length of a response header.
        pub fn response_header_length(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        /// Gets a response header.
        pub fn response_header_get(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        /// Sets a response header.
        pub fn response_header_set(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        /// Inserts a response cookie.
        pub fn response_cookie_insert(arg0: i32, arg1: i32) -> i32;
        /// Removes a response cookie.
        pub fn response_cookie_remove(arg0: i32, arg1: i32) -> i32;
        /// Gets the length of the response body.
        pub fn response_body_length(arg0: i32, arg1: i32) -> i32;
        /// Gets the response body.
        pub fn response_body_get(arg0: i32, arg1: i32, arg2: i32) -> i32;
        /// Sets the response body.
        pub fn response_body_set(arg0: i32, arg1: i32, arg2: i32) -> i32;
        /// Creates a new response cookie.
        pub fn cookie_new(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        /// Frees the response cookie.
        pub fn cookie_free(arg0: i32) -> i32;
        /// Sets the HttpOnly attribute on the cookie.
        pub fn cookie_http_only_set(arg0: i32) -> i32;
        /// Sets the Secure attribute on the cookie.
        pub fn cookie_secure_set(arg0: i32) -> i32;
        /// Sets the MaxAge attribute on the cookie.
        pub fn cookie_max_age_set(arg0: i32, arg1: i64) -> i32;
        /// Sets the SameSite attribute on the cookie.
        pub fn cookie_same_site_set(arg0: i32, arg1: i32) -> i32;
        /// Sets the Domain attribute on the cookie.
        pub fn cookie_domain_set(arg0: i32, arg1: i32, arg2: i32) -> i32;
        /// Sets the Path attribute on the cookie.
        pub fn cookie_path_set(arg0: i32, arg1: i32, arg2: i32) -> i32;
    }
}
